# Booth_Multiplier
In this project, we will design a Booth multiplier for unsigned 8-bit numbers. The multiplier will consist of two main components: the Booth encoder circuit and the adder circuit, as illustrated in the diagram below. The design will be fully parameterized, allowing the multiplier to handle n-bit numbers (where n is an even number). For the adder circuit, the Wallace Tree technique was employed to maximize computational efficiency.

![image_2025-03-17_015112292](https://github.com/user-attachments/assets/ad67fa7e-2014-4449-aa8a-fe48f49ee9a2)

## Booth Circuit
Booth encoding requires sign extension to function correctly. However, sign extension imposes a significant overhead on the circuit, as the additional bits result in more hardware, and consequently, higher cost and delay. By applying simple optimizations and utilizing the bit S=NEGi (where NEG is a signal from the Booth Cell Circuit), the following dot diagram is created for inputs of 16-bit. Each row of the diagram represents a partial product.

![image](https://github.com/user-attachments/assets/771d3829-f626-43a0-9808-2363314bc695)

The diagram below illustrates the structure of the Booth Circuit. The encoding steps are presented clearly for better understanding. The output of the circuit is a bit string that includes all the partial products.

![image_2025-03-17_020916733](https://github.com/user-attachments/assets/72f0168d-047c-470a-a786-39e4334a6969)

### Booth Cell
The Booth Cell is divided into two main components: the encoder and the selector. The encoder generates the signals SINGLEi, DOUBLEi, and NEGi, while the selector determines the appropriate form of the partial product. In this implementation, the outputs of the Booth Cell are the partial product and the NEGi signal. The inputs of our circuit is the proper triad derived from the first input (X), and the entirety of the second input (Y).

![image_2025-03-17_020237732](https://github.com/user-attachments/assets/7d24b542-6fad-488d-bbdf-b3fb2d5102bb)

## Booth encoding parameterization
The parameterization of Booth encoding is defined by the following equations, where n is the number of input bits:
* Number of partial products (K): $K = integer((n+3)/2)$
* Number of Booth Circuit's output bits (N): $N = K*(n+5)-4$
* Number of first partial product's bits: $n+4$
* Number of pre-last partial product's bits: $n+4$ 
* Number of last partial product's bits: $n+3$
* Number of other partial product's bits: $n+5$

## Wallace Tree (Adding Circuit)
Having the partial products generated by the Booth system, we proceed with designing the circuit that will sum these partial products. The circuit we chose to utilize is a Wallace tree. In general, column-wise addition can be slow, but one way to speed up the process is by summing the partial products in parallel rather than sequentially. The Wallace tree provides this capability for "accelerating" the addition. Specifically, a Wallace tree requires $$\log_{\frac{3}{2}}(K/2)$$ stages of carry save adders (CSA), where K the number of partial products. The input of the Wallace tree is the output of Booth circuit, and its output is the 2*n bits result.

![image_2025-03-17_030358547](https://github.com/user-attachments/assets/94f2bb6d-852b-4f60-8fef-6f9cf8aa6df2)

The implementation of Wallace Tree for N-bits is not optimal, as it does not produce the minimum number of circuit elements in the design. However, it provides a functional circuit to verify the operation of the N-bit Booth circuit. Its algorithm, though intricate, is thoroughly explained within the comments in the accompanying code files, offering valuable insights into its workings.

A simpler and hardware-efficient implementation for 8-bit operation is presented below. The circuit directly corresponds to the accompanying diagram and comprises three Carry Save Adders (CSAs) and one Carry Propagate Adder (CPA), which work together to add the partial products effectively.

![image_2025-03-17_032041249](https://github.com/user-attachments/assets/af88719c-8647-4935-9bfe-338080499d4e)









